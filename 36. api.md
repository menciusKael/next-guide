## 1. generateStaticParams

### 1.1. Introduction

`generateStaticParams` is used together with dynamic routing to statically generate routes at build time:

```javascript
// app/product/[id]/page.js
export function generateStaticParams() {
  return [{ id: "1" }, { id: "2" }, { id: "3" }];
}

// Correspondingly, 3 static routes will be generated:
// - /product/1
// - /product/2
// - /product/3
export default function Page({ params }) {
  const { id } = params;
  // ...
}
```

You can use fetch request in `generateStaticParams`. This example is closer to the actual development scenario:

```javascript
// app/blog/[slug]/page.js
export async function generateStaticParams() {
  const posts = await fetch("https://.../posts").then((res) => res.json());

  return posts.map((post) => ({
    slug: post.slug,
  }));
}

export default function Page({ params }) {
  const { slug } = params;
  // ...
}
```

About `generateStaticParams`:

- You can use the `dynamicParams` route segment configuration to control what happens when accessing a dynamic segment that was not generated by `generateStaticParams`
- In `next dev`, `generateStaticParams` is called when you navigate to the route
- In `next build`, `generateStaticParams` runs before the corresponding layout or page is generated
- In revalidation (ISR), `generateStaticParams` will not be called again
- `generateStaticParams` replaces the functionality of the `getStaticPaths` function under Pages Router

The above example handles a single dynamic segment, `generateStaticParams` can also handle multiple dynamic segments:

```javascript
// app/products/[category]/[product]/page.js
export function generateStaticParams() {
  return [
    { category: "a", product: "1" },
    { category: "b", product: "2" },
    { category: "c", product: "3" },
  ];
}

// Correspondingly, 3 static routes will be generated:
// - /products/a/1
// - /products/b/2
// - /products/c/3
export default function Page({ params }) {
  const { category, product } = params;
  // ...
}
```

Catch-all dynamic sections can also be handled:

```javascript
// app/product/[...slug]/page.js
export function generateStaticParams() {
  return [{ slug: ["a", "1"] }, { slug: ["b", "2"] }, { slug: ["c", "3"] }];
}

// Correspondingly, 3 static routes will be generated:
// - /product/a/1
// - /product/b/2
// - /product/c/3
export default function Page({ params }) {
  const { slug } = params;
  // ...
}
```

### 1.2. Parameters

`generateStaticParams` supports passing an optional `options.params` parameter. If multiple dynamic segments in a route use `generateStaticParams`, the child `generateStaticParams` function will be executed once for each `params` generated by the parent `generateStaticParams`.

What does this mean? For example, now we have a route address `/products/[category]/[product]`, which has two dynamic segments `[category]` and `[product]`. `[product]` depends on `[category]`. After all, you need to know the category first to know which products are under that category. To solve this problem:

First generate the parent segment:

```javascript
// app/products/[category]/layout.js
export async function generateStaticParams() {
  const products = await fetch("https://.../products").then((res) =>
    res.json()
  );

  return products.map((product) => ({
    category: product.category.slug,
  }));
}

export default function Layout({ params }) {
  // ...
}
```

The child `generateStaticParams` function can then use the `params` parameter returned by the parent `generateStaticParams` function to dynamically generate its own segments:

```javascript
// app/products/[category]/[product]/page.js
export async function generateStaticParams({ params: { category } }) {
  const products = await fetch(
    `https://.../products?category=${category}`
  ).then((res) => res.json());

  return products.map((product) => ({
    product: product.id,
  }));
}

export default function Page({ params }) {
  // ...
}
```

In this example, the `params` object contains the `params` generated from the parent `generateStaticParams`, which can be used to generate the `params` of the child segment.

This way of filling dynamic segments is called "​**Top-down parameter generation**​", and the child segment depends on the data of the parent segment. But if there is no dependency, such as providing an interface to directly return all products and corresponding catalog information, it can be directly generated. The sample code is as follows:

```javascript
// app/products/[category]/[product]/page.js
export async function generateStaticParams() {
  const products = await fetch("https://.../products").then((res) =>
    res.json()
  );

  return products.map((product) => ({
    category: product.category.slug,
    product: product.id,
  }));
}

export default function Page({ params }) {
  // ...
}
```

No need to write a parent `generateStaticParams` function, just do it in one step. This way of filling dynamic segments is called "​**Generate parameters from bottom to top**​".

### 1.3. Return value

`generateStaticParams` should return an array of objects, where each object represents the filled dynamic segment of a single route:

- Each attribute of the object is a dynamic segment to be filled by the route
- The attribute name is the segment name, and the attribute value is the content that should be filled in the segment

Direct description is a bit complicated, but it is actually very simple, for example:

For a dynamic route like `/product/[id]`, `generateStaticParams` should return an object similar to `[{id: xxx}, {id: xxx}, ...]`.

For a dynamic route like `/products/[category]/[product]`, `generateStaticParams` should return an object like `[{category: xxx, product: xxx}, {category: xxx, product: xxx}, ...]`.

For a dynamic route like `/products/[...slug]`, `generateStaticParams` should return an object like `[{slug: [xxx, xxx, ...]}, {slug: [xxx, xxx, ...]}, ...]`.

The return type is described as follows:

| **Example route**                | **generateStaticParams return type**      |
| -------------------------------- | ----------------------------------------- |
| `/product/[id]`                  | `{ id: string }[]`                        |
| `/products/[category]/[product]` | `{ category: string, product: string }[]` |
| `/products/[...slug]`            | `{ slug: string[] }[]`                    |

## 2. generateViewport

You can customize the initial viewport of the page in two ways:

1. Use a static `viewport` object
2. Use a dynamic `generateViewport` function

Note when using:

1. `viewport` object and `generateViewport` function **only support export in server-side components**
2. The `viewport` object and `generateViewport` function cannot be exported at the same time in the same route segment
3. If the viewport does not depend on some runtime information, try to define it using the `viewport` object

### 2.1. viewport object

Export an object named `viewport` from `layout.js` or `page.js`:

```javascript
// layout.js | page.js
export const viewport = {
  themeColor: "black",
};

export default function Page() {}
```

### 2.2. generateViewport

Export a function named `generateViewport` from `layout.js` or `page.js` that returns a Viewport object containing one or more viewport fields:

```javascript
export function generateViewport({ params }) {
  return {
    themeColor: "...",
  };
}
```

### 2.3. Viewport Field

#### themeColor

[theme-color](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTML%2FElement%2Fmeta%2Fname%2Ftheme-color "https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta/name/theme-color")，The user's browser will change the user interface based on the suggested color you set, for example, after setting the color in Chrome on Android:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1883c72300c54e49acc88652d7edaa04~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=894&h=686&s=103058&e=png&a=1&b=0385f7) Supports simple theme color settings:

```javascript
// layout.js | page.js
export const viewport = {
  themeColor: "black",
};
```

The corresponding output is:

```html
<meta name="theme-color" content="black" />
```

Theme color settings with media attributes are also supported:

```javascript
export const viewport = {
  themeColor: [
    { media: "(prefers-color-scheme: light)", color: "cyan" },
    { media: "(prefers-color-scheme: dark)", color: "black" },
  ],
};
```

The corresponding output is:

```javascript
<meta name="theme-color" media="(prefers-color-scheme: light)" content="cyan" />
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black" />
```

#### `width`, `initialScale`, 和 `maximumScale`

This is actually the default setting for the `viewport` meta tag and usually does not need to be set manually:

```javascript
// layout.js | page.js
export const viewport = {
  width: "device-width",
  initialScale: 1,
  maximumScale: 1,
  // Also supports
  // interactiveWidget: 'resizes-visual',
};
```

The corresponding output is:

```javascript
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1"
/>
```

#### colorScheme

[colorScheme](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTML%2FElement%2Fmeta%2Fname "https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta/name")，Specifies one or more color schemes compatible with the current document. The browser will prioritize the value of this metadata before using the user's browser or device settings to determine the various default colors and element appearances on the page, such as background color, foreground color, form controls, and scroll bars. The main purpose of is to indicate the compatibility of the current page with light mode and dark mode, and the priority order when using these two modes. Its values ​​are `normal`, `light`, `dark`, `only light`.

```javascript
// layout.js | page.js
export const viewport = {
  colorScheme: "dark",
};
```

```javascript
<meta name="color-scheme" content="dark" />
```
