## 1. generateStaticParams

### 1.1. Introduction

`generateStaticParams` is used together with dynamic routing to statically generate routes at build time:

```javascript
// app/product/[id]/page.js
export function generateStaticParams() {
  return [{ id: "1" }, { id: "2" }, { id: "3" }];
}

// Correspondingly, 3 static routes will be generated:
// - /product/1
// - /product/2
// - /product/3
export default function Page({ params }) {
  const { id } = params;
  // ...
}
```

You can use fetch request in `generateStaticParams`. This example is closer to the actual development scenario:

```javascript
// app/blog/[slug]/page.js
export async function generateStaticParams() {
  const posts = await fetch("https://.../posts").then((res) => res.json());

  return posts.map((post) => ({
    slug: post.slug,
  }));
}

export default function Page({ params }) {
  const { slug } = params;
  // ...
}
```

About `generateStaticParams`:

- You can use the `dynamicParams` route segment configuration to control what happens when accessing a dynamic segment that was not generated by `generateStaticParams`
- In `next dev`, `generateStaticParams` is called when you navigate to the route
- In `next build`, `generateStaticParams` runs before the corresponding layout or page is generated
- In revalidation (ISR), `generateStaticParams` will not be called again
- `generateStaticParams` replaces the functionality of the `getStaticPaths` function under Pages Router

The above example handles a single dynamic segment, `generateStaticParams` can also handle multiple dynamic segments:

```javascript
// app/products/[category]/[product]/page.js
export function generateStaticParams() {
  return [
    { category: "a", product: "1" },
    { category: "b", product: "2" },
    { category: "c", product: "3" },
  ];
}

// Correspondingly, 3 static routes will be generated:
// - /products/a/1
// - /products/b/2
// - /products/c/3
export default function Page({ params }) {
  const { category, product } = params;
  // ...
}
```

Catch-all dynamic sections can also be handled:

```javascript
// app/product/[...slug]/page.js
export function generateStaticParams() {
  return [{ slug: ["a", "1"] }, { slug: ["b", "2"] }, { slug: ["c", "3"] }];
}

// Correspondingly, 3 static routes will be generated:
// - /product/a/1
// - /product/b/2
// - /product/c/3
export default function Page({ params }) {
  const { slug } = params;
  // ...
}
```

### 1.2. Parameters

`generateStaticParams` supports passing an optional `options.params` parameter. If multiple dynamic segments in a route use `generateStaticParams`, the child `generateStaticParams` function will be executed once for each `params` generated by the parent `generateStaticParams`.

What does this mean? For example, now we have a route address `/products/[category]/[product]`, which has two dynamic segments `[category]` and `[product]`. `[product]` depends on `[category]`. After all, you need to know the category first to know which products are under that category. To solve this problem:

First generate the parent segment:

```javascript
// app/products/[category]/layout.js
export async function generateStaticParams() {
  const products = await fetch("https://.../products").then((res) =>
    res.json()
  );

  return products.map((product) => ({
    category: product.category.slug,
  }));
}

export default function Layout({ params }) {
  // ...
}
```

The child `generateStaticParams` function can then use the `params` parameter returned by the parent `generateStaticParams` function to dynamically generate its own segments:

```javascript
// app/products/[category]/[product]/page.js
export async function generateStaticParams({ params: { category } }) {
  const products = await fetch(
    `https://.../products?category=${category}`
  ).then((res) => res.json());

  return products.map((product) => ({
    product: product.id,
  }));
}

export default function Page({ params }) {
  // ...
}
```

In this example, the `params` object contains the `params` generated from the parent `generateStaticParams`, which can be used to generate the `params` of the child segment.

This way of filling dynamic segments is called "​**Top-down parameter generation**​", and the child segment depends on the data of the parent segment. But if there is no dependency, such as providing an interface to directly return all products and corresponding catalog information, it can be directly generated. The sample code is as follows:

```javascript
// app/products/[category]/[product]/page.js
export async function generateStaticParams() {
  const products = await fetch("https://.../products").then((res) =>
    res.json()
  );

  return products.map((product) => ({
    category: product.category.slug,
    product: product.id,
  }));
}

export default function Page({ params }) {
  // ...
}
```

No need to write a parent `generateStaticParams` function, just do it in one step. This way of filling dynamic segments is called "​**Generate parameters from bottom to top**​".

### 1.3. Return value

`generateStaticParams` should return an array of objects, where each object represents the filled dynamic segment of a single route:

- Each attribute of the object is a dynamic segment to be filled by the route
- The attribute name is the segment name, and the attribute value is the content that should be filled in the segment

Direct description is a bit complicated, but it is actually very simple, for example:

For a dynamic route like `/product/[id]`, `generateStaticParams` should return an object similar to `[{id: xxx}, {id: xxx}, ...]`.

For a dynamic route like `/products/[category]/[product]`, `generateStaticParams` should return an object like `[{category: xxx, product: xxx}, {category: xxx, product: xxx}, ...]`.

For a dynamic route like `/products/[...slug]`, `generateStaticParams` should return an object like `[{slug: [xxx, xxx, ...]}, {slug: [xxx, xxx, ...]}, ...]`.

The return type is described as follows:

| **Example route**                | **generateStaticParams return type**      |
| -------------------------------- | ----------------------------------------- |
| `/product/[id]`                  | `{ id: string }[]`                        |
| `/products/[category]/[product]` | `{ category: string, product: string }[]` |
| `/products/[...slug]`            | `{ slug: string[] }[]`                    |

## 2. generateViewport

You can customize the initial viewport of the page in two ways:

1. Use a static `viewport` object
2. Use a dynamic `generateViewport` function

Note when using:

1. `viewport` object and `generateViewport` function **only support export in server-side components**
2. The `viewport` object and `generateViewport` function cannot be exported at the same time in the same route segment
3. If the viewport does not depend on some runtime information, try to define it using the `viewport` object

### 2.1. viewport object

Export an object named `viewport` from `layout.js` or `page.js`:

```javascript
// layout.js | page.js
export const viewport = {
  themeColor: "black",
};

export default function Page() {}
```

### 2.2. generateViewport

Export a function named `generateViewport` from `layout.js` or `page.js` that returns a Viewport object containing one or more viewport fields:

```javascript
export function generateViewport({ params }) {
  return {
    themeColor: "...",
  };
}
```

### 2.3. Viewport Field

#### themeColor

[theme-color](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTML%2FElement%2Fmeta%2Fname%2Ftheme-color "https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta/name/theme-color")，The user's browser will change the user interface based on the suggested color you set, for example, after setting the color in Chrome on Android:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1883c72300c54e49acc88652d7edaa04~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=894&h=686&s=103058&e=png&a=1&b=0385f7) Supports simple theme color settings:

```javascript
// layout.js | page.js
export const viewport = {
  themeColor: "black",
};
```

The corresponding output is:

```html
<meta name="theme-color" content="black" />
```

Theme color settings with media attributes are also supported:

```javascript
export const viewport = {
  themeColor: [
    { media: "(prefers-color-scheme: light)", color: "cyan" },
    { media: "(prefers-color-scheme: dark)", color: "black" },
  ],
};
```

The corresponding output is:

```javascript
<meta name="theme-color" media="(prefers-color-scheme: light)" content="cyan" />
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black" />
```

#### `width`, `initialScale`, 和 `maximumScale`

This is actually the default setting for the `viewport` meta tag and usually does not need to be set manually:

```javascript
// layout.js | page.js
export const viewport = {
  width: "device-width",
  initialScale: 1,
  maximumScale: 1,
  // Also supports
  // interactiveWidget: 'resizes-visual',
};
```

The corresponding output is:

```javascript
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1"
/>
```

#### colorScheme

[colorScheme](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTML%2FElement%2Fmeta%2Fname "https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta/name")，Specifies one or more color schemes compatible with the current document. The browser will prioritize the value of this metadata before using the user's browser or device settings to determine the various default colors and element appearances on the page, such as background color, foreground color, form controls, and scroll bars. The main purpose of is to indicate the compatibility of the current page with light mode and dark mode, and the priority order when using these two modes. Its values ​​are `normal`, `light`, `dark`, `only light`.

```javascript
// layout.js | page.js
export const viewport = {
  colorScheme: "dark",
};
```

```javascript
<meta name="color-scheme" content="dark" />
```

## 3. revalidatePath

### 3.1. Introduction

`revalidatePath` is used to clear cached data on a specific path on demand. It can be used in Node.js and Edge Runtimes.

When using `revalidatePath`, please be aware that in Next.js, the process of clearing the data cache and re-obtaining the latest data is called revalidation. Even if `revalidatePath` is called multiple times in a dynamic route segment, multiple revalidations will not be triggered immediately. Data will only be re-obtained and the cache will be updated when it is accessed next time.

### 3.2. Parameters

```javascript
revalidatePath(path: string, type?: 'page' | 'layout'): void;
```

- `path` can be a routing string (such as `/product/123`) or a file system address string (such as `/product/[slug]/page`), and must be less than 1024 characters
- `type` optional parameter, the address type to be revalidated, the value is `page` or `layout`

### 3.3. Return value

`revalidatePath` does not return any value

### 3.4. Examples

#### Revalidate a specific URL

```javascript
import { revalidatePath } from "next/cache";
revalidatePath("/blog/post-1");
```

#### Revalidate a page path

```javascript
import { revalidatePath } from "next/cache";
revalidatePath("/blog/[slug]", "page");
// also works with route groups
revalidatePath("/(main)/post/[slug]", "page");
```

Note that in this example, only the URL corresponding to the provided page file is revalidated, i.e., pages below it will not be revalidated, e.g. /`blog/[slug]` will not invalidate `/blog/[slug]/[author]` as well

#### Revalidate a layout path

```javascript
import { revalidatePath } from "next/cache";
revalidatePath("/blog/[slug]", "layout");
// Can also be used with routing groups
revalidatePath("/(main)/post/[slug]", "layout");
```

In this example, this will revalidate any page that uses this layout, i.e. /`blog/[slug]` will also invalidate `/blog/[slug]/[author]`

#### Revalidate All Data

```javascript
import { revalidatePath } from "next/cache";

revalidatePath("/", "layout");
```

This will clear the client-side route cache and revalidate the data cache on the next visit.

#### Server Action

```javascript
"use server";
// app/actions.js
import { revalidatePath } from "next/cache";

export default async function submit() {
  await submitForm();
  revalidatePath("/");
}
```

#### Route Handlers

```javascript
// app/api/revalidate/route.js
import { revalidatePath } from "next/cache";

export async function GET(request) {
  const path = request.nextUrl.searchParams.get("path");

  if (path) {
    revalidatePath(path);
    return Response.json({ revalidated: true, now: Date.now() });
  }

  return Response.json({
    revalidated: false,
    now: Date.now(),
    message: "Missing path to revalidate",
  });
}
```

## 4. revalidateTag

### 4.1. Introduction

`revalidateTag` is used to clear cached data of a specific tag on demand. It can be used in Node.js and Edge Runtimes.

When using `revalidateTag`, please be aware that in Next.js, the process of clearing the data cache and re-obtaining the latest data is called revalidation. Even if `revalidateTag` is called multiple times in a dynamic route segment, multiple revalidations will not be triggered immediately. Data will only be re-obtained and the cache updated when it is accessed next time.

### 4.2. Parameters

```javascript
revalidateTag(tag: string): void;
```

- tag indicates the tag to be revalidated. It must be less than or equal to 256 characters.

How to add tags:

```javascript
fetch(url, { next: { tags: [...] } });
```

### 4.3. Return value

`revalidateTag` does not return any value

### 4.4. Example

#### Server Action

```javascript
// app/actions.js
import { revalidateTag } from "next/cache";

export async function GET(request) {
  const tag = request.nextUrl.searchParams.get("tag");
  revalidateTag(tag);
  return Response.json({ revalidated: true, now: Date.now() });
}
```

#### Route Handlers

```javascript
// app/api/revalidate/route.js
import { revalidateTag } from "next/cache";

export async function GET(request) {
  const tag = request.nextUrl.searchParams.get("tag");
  revalidateTag(tag);
  return Response.json({ revalidated: true, now: Date.now() });
}
```

## 5. unstable_cache

### 5.1. Introduction

`unstable_cache` is used to cache the results of expensive operations (such as database queries) and reuse the results in subsequent requests. The usage example is as follows:

```javascript
import { getUser } from './data';
import { unstable_cache } from 'next/cache';

const getCachedUser = unstable_cache(
  async (id) => getUser(id),
  ['my-app-user']
);

export default async function Component({ userID }) {
  const user = await getCachedUser(userID);
  ...
}
```

### 5.2. Parameters

```javascript
const data = unstable_cache(fetchData, keyParts, options)();
```

- `fetchData`: an asynchronous function that gets the data to be cached, which returns a Promise
- `keyParts`: an array of cache key names, which must contain globally unique values
- `options`: used to control cache behavior, including:
- `tags`: an array of tags used to control cache invalidation
- `revalidate`: the number of seconds the cache needs to be revalidated

### 5.3. Return value

`unstable_cache` returns a function that, when called, returns a Promise that resolves to the cached data. If the data is not in the cache, the provided function is called, the result is cached and returned.

## 6. unstable_noStore

### 6.1. Introduction

`unstable_noStore` is used to declare the exit of static rendering and indicate that the component should not be cached. The usage example is as follows:

```javascript
import { unstable_noStore as noStore } from 'next/cache';

export default async function Component() {
  noStore();
  const result = await db.query(...);
  ...
}
```

`unstable_noStore` is equivalent to adding `cache: 'no-store'` to `fetch`. One advantage of `unstable_noStore` over `export const dynamic = 'force-dynamic'` is that it is more fine-grained and can be used on a per-component basis.

### 6.2. Examples

If you don't want to pass extra options like `cache: 'no-store'` or `next: { revalidate: 0 }` to `fetch`, you can use `noStore()` instead.

```javascript
import { unstable_noStore as noStore } from 'next/cache';

export default async function Component() {
  noStore();
  const result = await db.query(...);
  ...
}
```

## 7. useSelectedLayoutSegment

### 7.1. Introduction

`useSelectedLayoutSegment` is a client component hook that reads the active route segment one level lower than the layout where the method is called. This feature is very useful for navigation UI, such as tabs in the parent layout, which need to change the style according to the current route segment. The basic usage sample code is as follows:

```javascript
"use client";
// app/example-client-component.js
import { useSelectedLayoutSegment } from "next/navigation";

export default function ExampleClientComponent() {
  const segment = useSelectedLayoutSegment();

  return <p>Active segment: {segment}</p>;
}
```

To explain the function and usage of this hook, let's write a demo. The demo effect is as follows:

![1115.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a02042ee7ef4d379e4540e093f0bad7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=458&h=209&s=52469&e=gif&f=30&b=fefefe)

This demo simulates clicking the sidebar to switch the current article. You can see that as the route switches, the style of the corresponding link also changes. The code is as follows:

```javascript
// app/blog/layout.js
import BlogNavLink from "./blog-nav-link";
import getFeaturedPosts from "./get-featured-posts";

export default async function Layout({ children }) {
  const featuredPosts = await getFeaturedPosts();
  return (
    <div>
      {featuredPosts.map((post) => (
        <div key={post.id}>
          <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink>
        </div>
      ))}
      <div>{children}</div>
    </div>
  );
}
```

```javascript
"use client";
// app/blog/blog-nav-link.js
import Link from "next/link";
import { useSelectedLayoutSegment } from "next/navigation";

export default function BlogNavLink({ slug, children }) {
  const segment = useSelectedLayoutSegment();
  const isActive = slug === segment;

  return (
    <Link
      href={`/blog/${slug}`}
      style={{ fontWeight: isActive ? "bold" : "normal" }}
    >
      {children}
    </Link>
  );
}
```

```javascript
// app/blog/get-featured-posts.js
export default async function getFeaturedPosts() {
  await new Promise((resolve) => setTimeout(resolve, 3000));
  return [
    { id: "1", slug: "article1", title: " 1" },
    { id: "2", slug: "article2", title: " 2" },
    { id: "3", slug: "article3", title: "3" },
  ];
}
```

```javascript
// app/blog/[slug]/page.js
export default function Page({ params }) {
  return <div>当前 slug: {params.slug}</div>;
}
```

In this example, `useSelectedLayoutSegment` is called in the layout `app/blog/layout.js`, so when accessing `/blog/article1`, the route segment one level lower than this layout is returned, that is, `article1` is returned. Then we make a judgment based on the return value and the current slug in `blog-nav-link.js`, thereby realizing the bolding function of the current link.

`useSelectedLayoutSegment` returns the active route segment one level lower than the layout where the method is called. That is to say, even if you visit `blog/article1/about`, because the layout that calls the method is still `app/blog/layout.js`, the returned value is still `article1`.

### 7.2 Parameters

```javascript
const segment = useSelectedLayoutSegment(parallelRoutesKey?: string)
```

`useSelectedLayoutSegment` accepts an optional parallelRoutesKey parameter, which is used to read the active route segment in the parallel route.

### 7.3 Return value

If it does not exist, it will return `null`. Let's look at a few more examples:

| **Layout**                | **Access URL**                 | **Return value** |
| ------------------------- | ------------------------------ | ---------------- |
| `app/layout.js`           | `/`                            | `null`           |
| `app/layout.js`           | `/dashboard`                   | `'dashboard'`    |
| `app/dashboard/layout.js` | `/dashboard`                   | `null`           |
| `app/dashboard/layout.js` | `/dashboard/settings`          | `'settings'`     |
| `app/dashboard/layout.js` | `/dashboard/analytics`         | `'analytics'`    |
| `app/dashboard/layout.js` | `/dashboard/analytics/monthly` | `'analytics'`    |

## 8. useSelectedLayoutSegments

### 8.1. Introduction

`useSelectedLayoutSegments` is a client component hook that reads all active route segments under the layout where the method is called.

The difference between `useSelectedLayoutSegments` and `useSelectedLayoutSegment` is:

- `useSelectedLayoutSegment` returns the active route segment of the next level of the layout
- `useSelectedLayoutSegments` returns all active route segments under the layout

Take the demo in the above section as an example, when these two methods are called in the `app/blog/layout.js` layout:

Visit `/blog/article1`, `useSelectedLayoutSegment` returns `'article1'`, and `useSelectedLayoutSegments` returns `<span> </span>`['article1']\`\`.

Visit `/blog/article1/about`, `useSelectedLayoutSegment` returns `'article1'`, and `useSelectedLayoutSegments` returns `['article1', 'about']`.

`useSelectedLayoutSegments` can be used to implement functions such as breadcrumbs. The basic usage sample code is as follows:

```javascript
"use client";
// app/example-client-component.js
import { useSelectedLayoutSegments } from "next/navigation";

export default function ExampleClientComponent() {
  const segments = useSelectedLayoutSegments();

  return (
    <ul>
      {segments.map((segment, index) => (
        <li key={index}>{segment}</li>
      ))}
    </ul>
  );
}
```

### 8.2.parameter

```javascript
const segments = useSelectedLayoutSegments(parallelRoutesKey?: string)
```

### 8.3. Return value

Returns as an array, or an empty array if none. Note that if a route group is used, it will also be returned, so you can use another `filter()` to exclude entries that start with a bracket. Let's look at a few more examples:

| **Layout**                | **Access URL**        | **Return value**            |
| ------------------------- | --------------------- | --------------------------- |
| `app/layout.js`           | `/`                   | `[]`                        |
| `app/layout.js`           | `/dashboard`          | `['dashboard']`             |
| `app/layout.js`           | `/dashboard/settings` | `['dashboard', 'settings']` |
| `app/dashboard/layout.js` | `/dashboard`          | `[]`                        |
| `app/dashboard/layout.js` | `/dashboard/settings` | `['settings']`              |
