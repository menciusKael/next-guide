## React Server Components

On December 21, 2020, React officially released [introduction article] of React Server Components(https://link.juejin.cn/?target=https%3A%2F%2Flegacy.reactjs.org%2Fblog%2F2020%2F12%2F21%2Fdata-fetching-with-react-server-components.html "https://legacy.reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html")，It is accompanied by an approximately 1 hour long [share] shared by Dan Abramov and Lauren Tan, two engineers from the React team. (https://link.juejin.cn/?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Ftime_continue%3D15%26v%3DTQQPAU21ZUw%26embeds_referring_euri%3Dhttps%253A%252F%252Flegacy.reactjs.org%252F%26source_ve_path%3DMzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMjg2NjY%26feature%3Demb_logo "https://www.youtube.com/watch?time_continue=15&v=TQQPAU21ZUw&embeds_referring_euri=https%3A%2F%2Flegacy.reactjs.org%2F&source_ve_path=MzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMjg2NjY&feature=emb_logo") and [Demo](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Freactjs%2Fserver-components-demo "https://github.com/reactjs/server-components-demo")，Detailed introduction to the emergence background and usage of React Server Components.

Understanding React Server Components is crucial to understanding how Next.js renders. So let’s take a little space to review the main content of this speech.

Dan introduced three key points in application development:

![Data Fetching with React Server Components - YouTube - 1_41.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7680e211aaf54b7e803401b6ecd07a3c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2560&h=1440&s=838797&e=png&b=1b1d26)

These three points are **best user experience**, **easy maintenance** and **high performance**. However, it is difficult to take into account these three points. We use [Spotify](https://link.juejin.cn/?target=https%3A%2F%2Fopen.spotify.com%2Fartist%2F3WrFJ7ztbogyGnTHbHJFl2 "https://open.spotify.com/artist/3WrFJ7ztbogyGnTHbHJFl2") An example page from this website

![Data Fetching with React Server Components - YouTube - 1_57.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08de63dfe38a4a00bed2aac7ee7e5a2c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2560&h=1440&s=924428&e=png&b=161616)

This is a musician introduction page. The content mainly contains two areas, one is the hot singles area (TopTracks), and the other is the album catalog (Discography). If we want to simulate and implement such a page using React, we might write like this :

![Data Fetching with React Server Components - YouTube - 2_32.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe8ed72599f943f6bc1f0941e66f67d2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2560&h=1440&s=879724&e=png&b=1b1d26)

It looks very simple, but when we add data requests, the code will become like this:

![Data Fetching with React Server Components - YouTube - 4_10.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a76bc145a8414b7688f4a6375a1e6f74~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2560&h=1440&s=1141608&e=png&b=1b1d26)

We get the data from the top level and pass it to the required subcomponents. Although it can be solved with one request, such code is not easy to maintain.

For example, if a UI component is deleted in a later iteration, but the corresponding data is not deleted from the interface, this results in redundant data. Another example is that you add a field to the interface and then use it in a component, but you forget to pass this field in another component that references the component, which may lead to an error.

For ease of maintenance, we will want to return to the simple structure just now, and then each component is responsible for its own data request:

![Data Fetching with React Server Components - YouTube - 5_16.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c9c9bfbc7294b4bb3d7e2cf1d71d572~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2560&h=1440&s=935649&e=png&b=1b1d26)

But this is slow. Originally it could be solved with one request, but now it is split into three requests. Can't we take care of it all?

Let’s analyze the reasons. Why is it slow to split data requests into various components? Essentially, the client initiates multiple HTTP requests. If these requests are serial (for example, the TopTracks and Discography components need to send the request with the id data after the data of the ArtistDetails component is returned), it will be even slower. To solve this problem, there is React Server Component.

![Data Fetching with React Server Components - YouTube - 11_08.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83e451cb15214ca08d5049555136eaa7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2560&h=1440&s=604748&e=png&b=1b1d26)

React Server Component places the data request part on the server, and the server directly returns the component with data to the client.

The ultimate goal is: in the original case of only Client Components, the structure of a React tree is as follows:

![Data Fetching with React Server Components - YouTube - 48_03.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a404d317b3604eb4bb238b4efb8c3785~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2560&h=1440&s=557630&e=png&b=1b1d26)

After using React Server Component, the React tree will become:

![Data Fetching with React Server Components - YouTube - 46_49.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a06dcb1d2ea64333b0299a3752f66b3d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2560&h=1440&s=555556&e=png&b=1b1d26)

The yellow node represents React Server Component. On the server side, React will render it into a tree containing basic HTML tags and client component placeholders. Its structure is similar to:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08ced5fb4bd945f3aa9d48e520126ccc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=953&h=809&s=314046&e=png&b=fefdfd)

Because the data and structure of the client component are not known until client rendering, the client component is replaced with a special placeholder in the tree at this time.

Of course, this tree cannot be sent directly to the client. React will perform serialization processing. After the client receives it, it will reconstruct the React tree based on this data, then fill the placeholders with real client components and render the final result.

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/146a170c4626428db92e5624f5be0212~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=919&h=796&s=246213&e=png&b=fefefe)

Use React Server Component because the server component code is not bundled into the client code, which can reduce the bundle size. And in React Server Component, you can directly access back-end resources. Of course, because it runs on the server, there are some restrictions, such as useEffect and client events cannot be used.

In this sharing, Dan also mentioned Next.js and said that he would work with partners of the Next.js team to develop it so that everyone can use this feature.

![Data Fetching with React Server Components - YouTube - 42_56.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d17f67bc4ac4b399918343d0db3055b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2560&h=1440&s=332996&e=png&b=1b1d26)

## **Server-side Rendering**

**Server-side Rendering** ，Translated into Chinese as "server-side rendering" ，

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">// pages/ssr.js</span>
<span class="code-block-extension-codeLine" data-line-num="2">export default function Page({ data }) {</span>
<span class="code-block-extension-codeLine" data-line-num="3">  return <span class="xml">&lt;p&gt;{JSON.stringify(data)}&lt;/p&gt;</span></span>
<span class="code-block-extension-codeLine" data-line-num="4">}</span>
<span class="code-block-extension-codeLine" data-line-num="5"></span>
<span class="code-block-extension-codeLine" data-line-num="6">export async function getServerSideProps() {</span>
<span class="code-block-extension-codeLine" data-line-num="7">  const res = await fetch(`https://jsonplaceholder.typicode.com/todos`)</span>
<span class="code-block-extension-codeLine" data-line-num="8">  const data = await res.json()</span>
<span class="code-block-extension-codeLine" data-line-num="9"></span>
<span class="code-block-extension-codeLine" data-line-num="10">  return { props: { data } }</span>
<span class="code-block-extension-codeLine" data-line-num="11">}</span>
</code></pre>

From this example, it can be seen that SSRs before Next.js v12 were all obtained at the page level through methods such as' getServerSideProps', and then passed to each component through props, rendering the entire component tree as HTML on the server side.

However, HTML does not have a non interactive UI, and after the client renders HTML, they still need to wait for JavaScript to be fully downloaded and executed. JavaScript endows HTML with interactivity, and this stage is called hydration. At this point, the content becomes interactive UI.

From this process, we can see several drawbacks of SSR:

1. The data acquisition of SSR must be done before component rendering
2. The JavaScript of the component must be loaded onto the client first before it can start hydration
3. All components must first hydrate before interacting with any of them

It can be seen that SSR technology opens and closes the entire page, loads the data of the entire page, loads the JavaScript of the entire page, hydrates the entire page, and must also be executed in this order in a serial manner. If some parts are slow, it will lead to a decrease in overall efficiency.

In addition, SSR is only used for page initialization loading and has no effect on subsequent interactions, page updates, or data changes.
