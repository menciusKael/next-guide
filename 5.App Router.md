## Preface

During actual project development, some routing scenarios will be more complex. For example, there are many articles in the database, and it is impossible for us to define routes one by one. What should we do at this time? When organizing code, some routes are used for mobile terminals and some routes are used for PC terminals. How should I organize the code? How to render the page conditionally, such as displaying the login page when unauthorized? How to make the same route display different content according to different scenarios?

In this article, we will solve these problems one by one. In this article, you will feel the powerful routing function of App Router.

## 1. Dynamic Routes

Sometimes, you cannot know the routing address in advance, such as displaying the article content corresponding to the id based on the id parameter in the URL. There are so many articles that it is impossible for us to define routes one by one. In this case, dynamic routing is needed.

### 1.1. [folderName]

To use dynamic routing, you need to enclose the folder name in square brackets, such as `[id]`, `[slug]`. The name of this route will be passed as the `params` prop **layout** 、 **page** 、 **[route handler](https://juejin.cn/book/7307859898316881957/section/7308914343129645065#heading-4 "https://juejin.cn/book/7307859898316881957/section/7308914343129645065#heading-4")** and **[generateMetadata](https://juejin.cn/book/7307859898316881957/section/7309079119902277669#heading-3 "https://juejin.cn/book/7307859898316881957/section/7309079119902277669#heading-3")** function。

For example, we create a new folder named `[slug]` in the `app/blog` directory, and create a new `page.js` file in the folder. The code is as follows:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">// app/blog/[slug]/page.js</span>
<span class="code-block-extension-codeLine" data-line-num="2">export default function Page({ params }) {</span>
<span class="code-block-extension-codeLine" data-line-num="3">  return <span class="xml">&lt;div&gt;My Post: {params.slug}&lt;/div&gt;</span></span>
<span class="code-block-extension-codeLine" data-line-num="4">}</span>
</code></pre>

The effect is as follows:

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88ee11229ac6473682f4f4344a34a285~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=690\&h=208\&s=24236\&e=png\&b=000000)

When you visit `/blog/a`, the value of `params` is `{ slug: 'a' }`.

When you visit `/blog/yayu`, the value of `params` is `{ slug: 'yayu' }`.

And so on.

### 1.2. [...folderName]

When naming a folder, if you add an ellipse inside the square brackets, such as `[...folderName]`, this means that all following routing fragments are captured.

In other words, `app/shop/[...slug]/page.js` will match `/shop/clothes`, as well as `/shop/clothes/tops`, `/shop/clothes/tops/t -shirts` and so on.

For example, the code of `app/shop/[...slug]/page.js` is as follows:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">// app/shop/[...slug]/page.js</span>
<span class="code-block-extension-codeLine" data-line-num="2">export default function Page({ params }) {</span>
<span class="code-block-extension-codeLine" data-line-num="3">  return <span class="xml">&lt;div&gt;My Shop: {JSON.stringify(params)}&lt;/div&gt;</span></span>
<span class="code-block-extension-codeLine" data-line-num="4">}</span>
</code></pre>

The effect is as follows:

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90e8b8aa9599485b99832890b9895ac4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=726&h=206&s=28238&e=png&b=000000)

When you access `/shop/a`, the value of `params` is `{ slug: ['a'] }`.

When you access `/shop/a/b`, the value of `params` is `{ slug: ['a', 'b'] }`.

When you access `/shop/a/b/c`, the value of `params` is `{ slug: ['a', 'b', 'c'] }`.

And so on.

### 1.3. [[...folderName]]

**When naming a folder, if you add an ellipsis within the square brackets, such as `[[...folderName]]`, this means that all following routing fragments are optionally captured.**

In other words, `app/shop/[[...slug]]/page.js` will match `/shop`, as well as `/shop/clothes`, `/shop/clothes/tops`, `/ shop/clothes/tops/t-shirts` etc.

The difference between it and the previous one is that routes without parameters will also be matched (such as `/shop`)

For example, the code of `app/shop/[[...slug]]/page.js` is as follows:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">// app/shop/[[...slug]]/page.js</span>
<span class="code-block-extension-codeLine" data-line-num="2">export default function Page({ params }) {</span>
<span class="code-block-extension-codeLine" data-line-num="3">  return <span class="xml">&lt;div&gt;My Shop: {JSON.stringify(params)}&lt;/div&gt;</span></span>
<span class="code-block-extension-codeLine" data-line-num="4">}</span>
</code></pre>

The effect is as follows:

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/788b14ff953e4ecaac29c87301406ec9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=702&h=210&s=22349&e=png&b=000000)

When you visit `/shop`, the value of params is `{}`.

When you access `/shop/a`, the value of params is `{ slug: ['a'] }`.

When you access `/shop/a/b`, the value of params is `{ slug: ['a', 'b'] }`.

When you access `/shop/a/b/c`, the value of params is `{ slug: ['a', 'b', 'c'] }`.

And so on.

## 2. Route groups

In the `app` directory, folder names are usually mapped to URLs, but you can mark folders as routing groups to prevent folder names from being mapped to URLs.

Using route groups, you can logically group routes and project files without affecting the URL path structure. Routing groups can be used for example:

1. Group routes by site, intent, team, etc.
2. Create multiple layouts in the same level, even create multiple root layouts

So how to mark it? Just enclose the folder in parentheses, like `(dashboard)`.

Some examples:

### 2.1. Group logically

**Group routes logically without affecting URL paths:**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01f171f5820742ba9a017c99b15a3fd7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1600&h=930&s=471042&e=png&b=171717)

You'll notice that the parenthesized folders (`(marketing)` and `(shop)` in the image above) are omitted from the final URL.

### 2.2. Create different layouts

**With routing groups, you can create different layouts even at the same level:**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4039b04e7b244f13aeaa4eca7482fd48~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1600&h=930&s=466548&e=png&b=171717)

In this example, `/account`, `/cart`, and `/checkout` are all at the same level. But `/account` and `/cart` use the `/app/(shop)/layout.js` layout and `app/layout.js` layout, and `/checkout` uses `app/layout.js`

### 2.3. Create multiple root layouts

**Create multiple root layouts:**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab457a10df414024bfcc33dad6d7641d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1600&h=687&s=335556&e=png&b=151515)

To create multiple root layouts, you need to delete the `app/layout.js` file and create a `layout.js` file for each group. When creating, please note that because it is the root layout, there must be `<html>` and `<body>` tags.

This function is very practical. For example, if you put the front-end purchase page and the back-end management page in one project, one on the C side and one on the B side, the layout of the two projects will definitely be different. With the help of routing groups, you can easily distinguish them.

A few more points:

1. The naming of routing groups has no special meaning other than for organization. They do not affect URL paths.
2. Be careful not to resolve to the same URL path. For example, because routing groups do not affect URL paths, both `(marketing)/about/page.js` and `(shop)/about/page.js` will be resolved to `/about`, which will cause an error.
3. When creating multiple root layouts, because the top-level `app/layout.js` file is deleted, an error will be reported when accessing `/`, so `app/page.js` needs to be defined in one of the routing groups.
4. Cross-root layout navigation will cause the page to be completely reloaded, such as `/cart` using the `app/(shop)/layout.js` root layout and jumping to the `app/(marketing)/layout.js` root Layout `/blog` will cause the page to reload (full page load).

Note: Problems may arise when using `app/not-found.js` when defining multiple root layouts.
