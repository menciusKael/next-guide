##Preface

In this article, we will continue to discuss the caching mechanism of Next.js. Today we will introduce the complete routing cache and routing cache.

##1 Full Route Cache

###1.1 operational principle

Next.js will automatically render and cache routes during \* \* construction, so that when accessing routes, the cached routes can be directly used instead of rendering from scratch on the server, thereby accelerating page loading speed.

So you might ask, what kind of ghost is cache routing? I have heard of caching data, but how do routers cache it? Let's review the rendering principles of Next.js:

Next.js uses React's API to orchestrate rendering. When rendering, the rendering work will be split into multiple chunks based on routing and Suspension, and each chunk will be rendered in two steps:

1. React will render server-side components into a special data format, which we call React Server Component Payload, abbreviated as RSC Payload. For example, the code for a server-side component is:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">&lt;div&gt;</span>
<span class="code-block-extension-codeLine" data-line-num="2">  Don’t give up and don’t give in.</span>
<span class="code-block-extension-codeLine" data-line-num="3">  &lt;ClientComponent /&gt;</span>
<span class="code-block-extension-codeLine" data-line-num="4">&lt;/div&gt;</span>
</code></pre>

React will convert it to the following Payload:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">[&#34;$&#34;,&#34;div&#34;,null,{&#34;children&#34;:[&#34;Don’t give up and don’t give in.&#34;, [&#34;$&#34;,&#34;$L1&#34;,null,{}]]}]</span>
<span class="code-block-extension-codeLine" data-line-num="2">1:I{&#34;id&#34;:123,&#34;chunks&#34;:[&#34;chunk/[hash].js&#34;],&#34;name&#34;:&#34;ClientComponent&#34;,&#34;async&#34;:false}</span>
</code></pre>

This format is optimized for streams, which can be sent line by line from the server to the client in the form of streams. The client can parse the RSC Payload line by line and gradually render the page.

Of course, this RSC payload code cannot be executed directly, as it contains more information:

1. The rendering results of server-side components
2. Placeholders and reference files of client components
3. Data passed from server-side components to client-side components

For example, the '$L1' in this RSC payload represents the ClientComponent. After receiving the RSC payload, the client will parse and download the bundle address corresponding to the ClientComponent, and then render the execution result to the position occupied by the '$L1'.

2. Next.js will use RSC payload and client component code to render HTML on the server side

This picture vividly depicts the process:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb119007336543c288845f29c425e014~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1600&h=888&s=171366&e=png&b=0d0d0d)

Simply put, there are two products of routing rendering, one is RSC Payload and the other is HTML. The complete routing cache contains these two products.

However, whether the route will be cached during construction depends on whether it is static or dynamic rendering. Static routes are cached by default, while dynamic routes are not cached because they can only be rendered at the time of a request. This image shows the difference between static rendering and dynamic rendering:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27d1e45c1c5849d2892dfad986832acc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1600&h=1314&s=351817&e=png&b=0c0c0c)

In this diagram, the static route '/a' will not be re rendered because it has a complete route cache. Dynamic routing '/b' does not have a complete routing cache, so it will be re rendered. But this does not affect the client's routing cache, so the routing cache is hit in subsequent requests.

###1.2 Duration

The complete routing cache is persistent by default, which means it can be reused across user requests.

###1.3 Failure mode

There are two ways to invalidate the complete routing cache:

*Revalidating data: revalidating the data cache will invalidate the complete routing cache, as rendering output depends on data
*Redeployment: Data caching can be cross deployed, but the complete routing cache will be cleared during redeployment

###1.4 Exit method

The way to exit the complete routing cache is to change it to dynamic rendering:

*Using dynamic functions: After using dynamic functions, it will be changed to dynamic rendering, and the data cache can still be used at this time
*Using the routing segment configuration option: 'dynamic='force dynamic' or 'validate=0' will skip the full routing cache and data cache, meaning that the data will be retrieved and the component will be rendered every time a request is made. At this point, the routing cache can still be used, as it is the client cache
\*Exiting data cache: If a fetch request in the route exits the cache, the complete route cache will be exited. This specific fetch request will be retrieved on each request, while other fetch requests will still use data caching. Next.js allows for a mixture of cached and uncached data

Simply put, the complete routing cache is only applicable to static rendering, and the products of static rendering, RSC Payload and HTML, are retained on the server.

Using dynamic rendering will exit the full routing cache. How to transition routing from static rendering to dynamic rendering, you can also refer to[](https://juejin.cn/book/7307859898316881957/section/7342031804771565619#heading-2 "https://juejin.cn/book/7307859898316881957/section/7342031804771565619#heading-2")。
