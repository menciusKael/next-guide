##Preface

In this chapter, we will introduce the caching mechanism of Next.js.

The caching function of Next.js is so powerful that it can be both loved and hated. On the one hand, the importance of caching is self-evident, as it can optimize application performance and reduce overhead. On the other hand, when writing Next.js projects, one often encounters the problem of data not being updated, mostly due to cache issues

In theory, caching is not a necessary knowledge for using Next.js. Because Next.js will automatically manage the cache based on the API you are using. But in reality, you still need to study caching seriously. At least you need to have a clear understanding of the caching mechanism of Next.js, its general working principle, and how to exit caching. Otherwise, when encountering caching problems, you may not even know how to solve them

Now let's study caching seriously.

##Overview

There are four caching mechanisms in Next.js:

| Mechanism            | Cache Content         | Storage Location | Purpose                                         | Period                     |
| -------------------- | --------------------- | ---------------- | ----------------------------------------------- | -------------------------- |
| Request Memorization | Function Return Value | Server           | Reuse Data in React Component Tree              | Lifecycle of Each Request  |
| Data Cache           | Data                  | Server           | Reuse data across user requests and deployments | Persistent (re verifiable) |
| Full Route Cache     | HTML and RSC payload  | Server           | Reduce rendering costs, improve performance     | Persistent (re verifiable) |
| Router Cache         | RSC payload           | Client           | Reduce server requests during navigation        | User session or time based |

By default, Next.js will use caching as much as possible to improve performance and reduce costs. Routing will default to static rendering, and the results of data requests will be cached by default. The following figure shows the schematic diagram of static routing rendering during construction and the first access to static routing:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e176beb2d77848f88f7790d9eb7ab720~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1600&h=1179&s=418691&e=png&b=0d0d0d)

In this picture:

When building a BUILD TIME, since the request in the route is for the first time, it will always be MISS. After obtaining data from the data source, a copy of the data is saved in both the request memory and data cache (SET), and the generated RSC payload and HTML are also saved in the server (full route cache).

When the client accesses'/a ', it hits the RSC Payload and HTML cached by the server, and saves a copy of the RSC Payload in the client (\* _ Routing Cache _ \*).

The caching behavior can change depending on many factors, such as whether the route is dynamically or statically rendered, whether the data is cached or uncached, and whether the request is in initialization access or subsequent navigation.

Are you a bit confused? It's okay, as the content unfolds, we will have a deeper understanding.
