##Preface

In this chapter, we will introduce the caching mechanism of Next.js.

The caching function of Next.js is so powerful that it can be both loved and hated. On the one hand, the importance of caching is self-evident, as it can optimize application performance and reduce overhead. On the other hand, when writing Next.js projects, one often encounters the problem of data not being updated, mostly due to cache issues

In theory, caching is not a necessary knowledge for using Next.js. Because Next.js will automatically manage the cache based on the API you are using. But in reality, you still need to study caching seriously. At least you need to have a clear understanding of the caching mechanism of Next.js, its general working principle, and how to exit caching. Otherwise, when encountering caching problems, you may not even know how to solve them

Now let's study caching seriously.

##Overview

There are four caching mechanisms in Next.js:

| Mechanism            | Cache Content         | Storage Location | Purpose                                         | Period                     |
| -------------------- | --------------------- | ---------------- | ----------------------------------------------- | -------------------------- |
| Request Memorization | Function Return Value | Server           | Reuse Data in React Component Tree              | Lifecycle of Each Request  |
| Data Cache           | Data                  | Server           | Reuse data across user requests and deployments | Persistent (re verifiable) |
| Full Route Cache     | HTML and RSC payload  | Server           | Reduce rendering costs, improve performance     | Persistent (re verifiable) |
| Router Cache         | RSC payload           | Client           | Reduce server requests during navigation        | User session or time based |

By default, Next.js will use caching as much as possible to improve performance and reduce costs. Routing will default to static rendering, and the results of data requests will be cached by default. The following figure shows the schematic diagram of static routing rendering during construction and the first access to static routing:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e176beb2d77848f88f7790d9eb7ab720~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1600&h=1179&s=418691&e=png&b=0d0d0d)

In this picture:

When building a BUILD TIME, since the request in the route is for the first time, it will always be MISS. After obtaining data from the data source, a copy of the data is saved in both the request memory and data cache (SET), and the generated RSC payload and HTML are also saved in the server (full route cache).

When the client accesses'/a ', it hits the RSC Payload and HTML cached by the server, and saves a copy of the RSC Payload in the client (\* _ Routing Cache _ \*).

The caching behavior can change depending on many factors, such as whether the route is dynamically or statically rendered, whether the data is cached or uncached, and whether the request is in initialization access or subsequent navigation.

Are you a bit confused? It's okay, as the content unfolds, we will have a deeper understanding.

## 1. （Request Memoization）

### 1.1. operational principle

React has expanded [fetch API](https://link.juejin.cn/?target=https%3A%2F%2Fnextjs.org%2Fdocs%2Fapp%2Fbuilding-your-application%2Fcaching%23fetch "https://nextjs.org/docs/app/building-your-application/caching#fetch")，When there are identical URLs and parameters, React will automatically cache the request results. That is to say, even if you request the same data at multiple locations in the component tree, data retrieval will only be performed once.

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcd22d593060474fa2a7437337469aa0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1600&h=857&s=666460&e=png&b=141414)

In this way, when you cross routes (such as layouts, pages, and components), you don't need to request data at the top level, and then forward the returned results through props. You can directly request data from the components that need it, without worrying about the performance impact of making multiple requests to the same data.

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">// app/page.js</span>
<span class="code-block-extension-codeLine" data-line-num="2">async function getItem() {</span>
<span class="code-block-extension-codeLine" data-line-num="3">  // Automatically cache results</span>
<span class="code-block-extension-codeLine" data-line-num="4">  const res = await fetch(&#39;https://.../item/1&#39;)</span>
<span class="code-block-extension-codeLine" data-line-num="5">  return res.json()</span>
<span class="code-block-extension-codeLine" data-line-num="6">}</span>
<span class="code-block-extension-codeLine" data-line-num="7"></span>
<span class="code-block-extension-codeLine" data-line-num="8">// Call the function twice, but only execute the request once</span>
<span class="code-block-extension-codeLine" data-line-num="9">const item = await getItem() // cache MISS</span>
<span class="code-block-extension-codeLine" data-line-num="10"></span>
<span class="code-block-extension-codeLine" data-line-num="11">const item = await getItem() // cache HIT</span>
</code></pre>

This is the working principle diagram of requesting memory:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b9746cb977d49888c846ea230f99fa1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1600&h=800&s=149814&e=png&b=0e0e0e)

In this diagram, when rendering the '/a' route, as it is the first request, cache 'MISS' will be triggered, the function will be executed, and the request result will be stored in memory (cache' SET '). When the next same call occurs, cache' HIT 'will be triggered, and data will be directly retrieved from memory.

The principle behind it must have been thought of by everyone, which is [function memory] (https://juejin.cn/post/6844903494256705543 "https://juejin.cn/post/6844903494256705543")，There are similar functions in the JavaScript Authoritative Guide:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">function memoize(f) {</span>
<span class="code-block-extension-codeLine" data-line-num="2">    var cache = {};</span>
<span class="code-block-extension-codeLine" data-line-num="3">    return function(){</span>
<span class="code-block-extension-codeLine" data-line-num="4">        var key = arguments.length + Array.prototype.join.call(arguments, &#34;,&#34;);</span>
<span class="code-block-extension-codeLine" data-line-num="5">        if (key in cache) {</span>
<span class="code-block-extension-codeLine" data-line-num="6">            return cache[key]</span>
<span class="code-block-extension-codeLine" data-line-num="7">        }</span>
<span class="code-block-extension-codeLine" data-line-num="8">        else return cache[key] = f.apply(this, arguments)</span>
<span class="code-block-extension-codeLine" data-line-num="9">    }</span>
<span class="code-block-extension-codeLine" data-line-num="10">}</span>
</code></pre>

Regarding requesting memory, attention should be paid to:

*Request memory is a feature of React, not Next.js. Both React and Next.js have implemented request caching. React's solution is called "request memory", while Next.js's solution is called "data caching", with many differences between the two
*Request memory is only suitable for fetch requests using the GET method
\*Request memory is only applied to the React component tree, which means that using fetch in `generateMetada`, `generateStaticParams`, layout, pages, and other server-side components will trigger request memory, but it will not be triggered when used in routing handlers because it is not in the React component tree anymore

###1.2 Duration

Caching will continue throughout the lifecycle of server requests until the React component tree is fully rendered. Its existence is to avoid the performance impact caused by multiple requests for the same data during component tree rendering.

###1.3 Re validate

Since the request memory will only be used during rendering, there is no need to revalidate it.

###1.4 Exit method

This behavior is the default optimization of React. It is not recommended to exit.

If you don't want the fetch request to be remembered, you can use [AbortController](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FAbortController "https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController") The specific usage of this web API is as follows (although its original purpose was to terminate requests):

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">const { signal } = new AbortController()</span>
<span class="code-block-extension-codeLine" data-line-num="2">fetch(url, { signal })</span>
</code></pre>

###1.5 React Cache

If you cannot use fetch requests but want to implement memory, you can use React's cache function:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">// utils/get-item.ts</span>
<span class="code-block-extension-codeLine" data-line-num="2">import { cache } from &#39;react&#39;</span>
<span class="code-block-extension-codeLine" data-line-num="3">import db from &#39;@/lib/db&#39;</span>
<span class="code-block-extension-codeLine" data-line-num="4"></span>
<span class="code-block-extension-codeLine" data-line-num="5">export const getItem = cache(async (id: string) =&gt; {</span>
<span class="code-block-extension-codeLine" data-line-num="6">  const item = await db.item.findUnique({ id })</span>
<span class="code-block-extension-codeLine" data-line-num="7">  return item</span>
<span class="code-block-extension-codeLine" data-line-num="8">})</span>
</code></pre>
