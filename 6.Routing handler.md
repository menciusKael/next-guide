## preface

Routing handler refers to using the Web [Request](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FRequest "https://developer.mozilla.org/en-US/docs/Web/API/Request") and [Response](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FResponse "https://developer.mozilla.org/en-US/docs/Web/API/Response") API Customize the processing logic for the given route.

Simply put, in a front-end and back-end separation architecture, the client and server interact through API interfaces. This "API interface" has a more formal name in Next.js, which is the routing handler.

In this article, we will explain how to define a routing handler and some common problems encountered when writing routing handlers.

## 1. Define routing handlers

To write a routing handler, you need to define a special file called 'route. js'. (Note that 'route' is not 'router')

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/babbee6771464a4f86b56a6ec8acc6f9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1600&h=444&s=212806&e=png&b=171717)

The file must be located in the 'app' directory and can be nested within the 'app' folder. However, it should be noted that 'page. js' and' route. js' cannot coexist at the same level.

It can also be understood that both 'page. js' and' route. js' are essentially responses to routing` Page. js is mainly responsible for rendering the UI, while route. js is mainly responsible for processing requests. If it exists simultaneously, Next.js will not know whose logic to use.

### 1.1. GET request

Let's start by writing GET requests, such as an interface to retrieve a list of articles.

Create a new 'app/app/posts/route. js' file with the following code:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">import { NextResponse } from &#39;next/server&#39;</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3">export async function GET() {</span>
<span class="code-block-extension-codeLine" data-line-num="4">  const res = await fetch(&#39;https://jsonplaceholder.typicode.com/posts&#39;)</span>
<span class="code-block-extension-codeLine" data-line-num="5">  const data = await res.json()</span>
<span class="code-block-extension-codeLine" data-line-num="6"></span>
<span class="code-block-extension-codeLine" data-line-num="7">  return NextResponse.json({ data })</span>
<span class="code-block-extension-codeLine" data-line-num="8">}</span>
</code></pre>

Browser Access`http://localhost:3000/api/posts`To view the data returned by the interface:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a067b254ed254d738e7384fcd1a13bb0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=3602&h=1482&s=412488&e=png&b=ffffff)

In this example:

1. We use an 'export' function called 'GET' to define the processing of GET requests. Please note that it is' export 'instead of' export default '
2. We use the NextResponse object of 'next/server' to set the response content, but it is not necessary to use 'NextResponse' here. It is also possible to use 'Response' directly:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">export async function GET() {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  const res = await fetch(&#39;https://jsonplaceholder.typicode.com/posts&#39;)</span>
<span class="code-block-extension-codeLine" data-line-num="3">  const data = await res.json()</span>
<span class="code-block-extension-codeLine" data-line-num="4"></span>
<span class="code-block-extension-codeLine" data-line-num="5">  return Response.json({ data })</span>
<span class="code-block-extension-codeLine" data-line-num="6">}</span>
</code></pre>

However, in practical development, it is recommended to use 'NextResponse' because it is a Next.js encapsulation based on 'Response', which is more TypeScript friendly and provides more convenient usage, such as obtaining cookies.

3. We have written the interface in the 'app/app' folder, not because the interface must be placed in a folder named 'api' (different from Pages Router). If your code is written in 'app/posts/route. js', the corresponding interface address is'/posts'. Placing it in the 'api' folder is only for the convenience of distinguishing whether the address is an interface or a page.

### 1.2. Supporting methods

The next. js supports HTTP request methods such as GET, POST, PUT, PATCH, Delete, HEAD, and Options. If an unsupported request method is passed in, the next. js will return ` 405 Do not allow method usage`

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">// route.js</span>
<span class="code-block-extension-codeLine" data-line-num="2">export async function GET(request) {}</span>
<span class="code-block-extension-codeLine" data-line-num="3"></span>
<span class="code-block-extension-codeLine" data-line-num="4">export async function HEAD(request) {}</span>
<span class="code-block-extension-codeLine" data-line-num="5"></span>
<span class="code-block-extension-codeLine" data-line-num="6">export async function POST(request) {}</span>
<span class="code-block-extension-codeLine" data-line-num="7"></span>
<span class="code-block-extension-codeLine" data-line-num="8">export async function PUT(request) {}</span>
<span class="code-block-extension-codeLine" data-line-num="9"></span>
<span class="code-block-extension-codeLine" data-line-num="10">export async function DELETE(request) {}</span>
<span class="code-block-extension-codeLine" data-line-num="11"></span>
<span class="code-block-extension-codeLine" data-line-num="12">export async function PATCH(request) {}</span>
<span class="code-block-extension-codeLine" data-line-num="13"></span>
<span class="code-block-extension-codeLine" data-line-num="14">// If 'Options' is not defined, Next.js will automatically implement it `OPTIONS`</span>
<span class="code-block-extension-codeLine" data-line-num="15">export async function OPTIONS(request) {}</span>
</code></pre>

Now let's write another POST request to practice our hands.

Continue to modify the 'app/app/posts/route. js' and add the following code:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">export async function POST(request) {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  const article = await request.json()</span>
<span class="code-block-extension-codeLine" data-line-num="3"></span>
<span class="code-block-extension-codeLine" data-line-num="4">  return NextResponse.json({</span>
<span class="code-block-extension-codeLine" data-line-num="5">    id: Math.random().toString(36).slice(-8),</span>
<span class="code-block-extension-codeLine" data-line-num="6">    data: article</span>
<span class="code-block-extension-codeLine" data-line-num="7">  }, { status: 201 })</span>
<span class="code-block-extension-codeLine" data-line-num="8">}</span>
</code></pre>

Now let's use Postman to call:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75d5b058673841c3b4f4b9ab75507c2a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1750&h=1030&s=170274&e=png&b=252525)

### 1.3. Pass in parameters

Now let's look at the request method in detail. The handler function of each request method will be passed in two parameters, one `request` and one `context`. Both parameters are optional:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">export async function GET(request, context) {}</span>
</code></pre>

#### request (optional)

request object is a [NextRequest](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-23 "https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-23") object, which is based on [Web Request API](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FRequest "https://developer.mozilla.org/en-US/docs/Web/API/Request") extension. Using request you can quickly read cookies and handle URLs.

Here we talk about how to get URL parameters:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">export async function GET(request, context) {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  //  访问 /home, pathname 的值为 /home</span>
<span class="code-block-extension-codeLine" data-line-num="3">	const pathname = request.nextUrl.pathname</span>
<span class="code-block-extension-codeLine" data-line-num="4">	// 访问 /home?name=lee, searchParams 的值为 { &#39;name&#39;: &#39;lee&#39; }</span>
<span class="code-block-extension-codeLine" data-line-num="5">	const searchParams = request.nextUrl.searchParams</span>
<span class="code-block-extension-codeLine" data-line-num="6">}</span>
</code></pre>

where nextUrl is an extension based on the Web URL API (if you want to get other values, refer to [URL API](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FURL "https://developer.mozilla.org/en-US/docs/Web/API/URL")），Some convenient methods are also provided.

#### context (optional)

Currently, `context` has only one value which is `params`, which is an object containing the current dynamic routing parameters. for example:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">// app/dashboard/[team]/route.js</span>
<span class="code-block-extension-codeLine" data-line-num="2">export async function GET(request, { params }) {</span>
<span class="code-block-extension-codeLine" data-line-num="3">  const team = params.team</span>
<span class="code-block-extension-codeLine" data-line-num="4">}</span>
</code></pre>

When accessing `/dashboard/1`, the value of params is `{ team: '1' }`. Other situations include:

| Example                          | URL            | params                    |
| -------------------------------- | -------------- | ------------------------- |
| `app/dashboard/[team]/route.js`  | `/dashboard/1` | `{ team: '1' }`           |
| `app/shop/[tag]/[item]/route.js` | `/shop/1/2`    | `{ tag: '1', item: '2' }` |
| `app/blog/[...slug]/route.js`    | `/blog/1/2`    | `{ slug: ['1', '2'] }`    |

Note the second line: params returns all dynamic routing parameters of the current link.

#### Sample code

Now let's write a demo to review this knowledge.

Requirements: Currently, GET request `/api/posts` will return all article data. Now we hope that GET request `/api/posts/1?dataField=title` will obtain the article data with post id 1. dataField is used to specify which fields to return. data.

Let's start writing. Create a new `/api/posts/[id]/route.js` with the following code:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">import { NextResponse } from &#39;next/server&#39;</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3">export async function GET(request, { params }) {</span>
<span class="code-block-extension-codeLine" data-line-num="4">  const field = request.nextUrl.searchParams.get(&#34;dataField&#34;)</span>
<span class="code-block-extension-codeLine" data-line-num="5">  const data = await ((await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`)).json())</span>
<span class="code-block-extension-codeLine" data-line-num="6">  const result = field ? { [field]: data[field] } : data</span>
<span class="code-block-extension-codeLine" data-line-num="7">  return NextResponse.json(result)</span>
<span class="code-block-extension-codeLine" data-line-num="8">}</span>
</code></pre>

Use Postman to test it. If the request address is `http://localhost:3000/api/posts/1?dataField=title`, the effect is as follows:

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfbe33a5acae40978e0633c66953be55~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1828&h=798&s=143154&e=png&b=222222)

If the request address is `http://localhost:3000/api/posts/1`, the effect is as follows:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5eebccd5d7b41f5a8614c18364702b8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1826&h=876&s=177175&e=png&b=232323)

### 1.4. caching behavior

#### Default cache

By default, GET requests using a `Response` object (same as `NextResponse`) are cached.

Let us take an example, create a new `app/api/time/route.js`, the code is as follows:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">export async function GET() {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  console.log(&#39;GET /api/time&#39;)</span>
<span class="code-block-extension-codeLine" data-line-num="3">  return Response.json({ data: new Date().toLocaleTimeString() })</span>
<span class="code-block-extension-codeLine" data-line-num="4">}</span>
</code></pre>

Note: In development mode, it will not be cached, and the refresh time will change every time:

![get-cache.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d95418beb1214522a86c15aebde94538~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=521&h=144&s=22089&e=gif&f=27&b=fefefe)

Now we deploy the production version by running `npm run build && npm run start`:

![get-cache-1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/114035e161cb479b9aa4e12cc036ba94~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=521&h=144&s=16832&e=gif&f=23&b=fefefe)

You will find that no matter how you refresh, the time will not change. This is cached.

But why? How is Next.js implemented?

Let’s look at the command line output when building (npm run build):

![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/403817cc707a4a95ad6c994d03353ccc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1418&h=1368&s=1535239&e=png&b=090316)

According to the output results, you will find that `/api/time` is static, that is, it is pre-rendered as static content. In other words, the return result of `/api/time` is actually determined at the time of construction, and It is not determined on the first request.

#### Exit cache

Exit the cache, but you don’t have to worry about the impact of the default cache. In fact, the default caching conditions are very "strict", and these conditions will cause the cache to be exited:

- `GET` requests use the `Request` object

Modify `app/api/time/route.js`, the code is as follows:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">export async function GET(request) {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  const searchParams = request.nextUrl.searchParams</span>
<span class="code-block-extension-codeLine" data-line-num="3">  return Response.json({ data: new Date().toLocaleTimeString(), params: searchParams.toString() })</span>
<span class="code-block-extension-codeLine" data-line-num="4">}</span>
</code></pre>

Now we deploy the production version by running `npm run build && npm run start`:

![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55aceee3f8c340359a8517ee57903212~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1340&h=1326&s=1393960&e=png&b=090316)

The running effect is as follows:

![get-cache-2.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bfa4f4e118343c795d4f377826f525e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=521&h=144&s=25261&e=gif&f=19&b=fdfdfd)

At this time, dynamic rendering will be performed, that is, server-side rendering will be performed when the request is made, so the time will change.

- Add other HTTP methods, such as POST

Modify `app/api/time/route.js`, the code is as follows:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">export async function GET() {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  console.log(&#39;GET /api/time&#39;)</span>
<span class="code-block-extension-codeLine" data-line-num="3">  return Response.json({ data: new Date().toLocaleTimeString() })</span>
<span class="code-block-extension-codeLine" data-line-num="4">}</span>
<span class="code-block-extension-codeLine" data-line-num="5"></span>
<span class="code-block-extension-codeLine" data-line-num="6">export async function POST() {</span>
<span class="code-block-extension-codeLine" data-line-num="7">  console.log(&#39;POST /api/time&#39;)</span>
<span class="code-block-extension-codeLine" data-line-num="8">  return Response.json({ data: new Date().toLocaleTimeString() })</span>
<span class="code-block-extension-codeLine" data-line-num="9">}</span>
</code></pre>

At this point it will switch to dynamic rendering. This is because POST requests are often used to change data, and GET requests are used to obtain data. If a POST request is written, it means that the data will change and is not suitable for caching at this time.

- Use [dynamic functions] like cookies and headers
- (https://juejin.cn/book/7307859898316881957/section/7309076661532622885#heading-9 "https://juejin.cn/book/7307859898316881957/section/7309076661532622885#heading-9")

Modify `app/api/time/route.js`, the code is as follows:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">export async function GET(request) {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  const token = request.cookies.get(&#39;token&#39;)</span>
<span class="code-block-extension-codeLine" data-line-num="3">  return Response.json({ data: new Date().toLocaleTimeString() })</span>
<span class="code-block-extension-codeLine" data-line-num="4">}</span>
</code></pre>

At this point it will switch to dynamic rendering. This is because the specific values of cookies and headers are only known when requested.

- [Routing segment configuration items](https://juejin.cn/book/7307859898316881957/section/7309079033223446554#heading-3 "https://juejin.cn/book/7307859898316881957/section/7309079033223446554#heading-3")Manually declare dynamic mode

Modify `app/api/time/route.js`, the code is as follows:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">export const dynamic = &#39;force-dynamic&#39;</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3">export async function GET() {</span>
<span class="code-block-extension-codeLine" data-line-num="4">  return Response.json({ data: new Date().toLocaleTimeString() })</span>
<span class="code-block-extension-codeLine" data-line-num="5">}</span>
</code></pre>

At this point it will switch to dynamic rendering. This is because you manually set it to dynamic rendering mode...

#### Re-verify

In addition to exiting the cache, you can also set the cache expiration date, which is suitable for some pages of low importance and low expiration date.

There are two commonly used solutions, one is to use [routing segment configuration items](https://juejin.cn/book/7307859898316881957/section/7309079033223446554#heading-5 "https://juejin.cn/book/7307859898316881957/ section/7309079033223446554#heading-5").

Modify `app/api/time/route.js`, the code is as follows:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">export const revalidate = 10</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3">export async function GET() {</span>
<span class="code-block-extension-codeLine" data-line-num="4">  return Response.json({ data: new Date().toLocaleTimeString() })</span>
<span class="code-block-extension-codeLine" data-line-num="5">}</span>
</code></pre>

`export const revalidate = 10` means setting the revalidation frequency to 10s, but please note:

The effect of this code is not to set the server to automatically update `/api/time` every 10 seconds. Instead, wait at least 10 seconds before re-verifying.

For example, suppose you access `/api/time` now, and the time is set to 0s. If you continue to access it within 10s, `/api/time` will return the previously cached results. When 10s passes, suppose you access `/api/time` again in the 12ths. Although it exceeds 10s, the previously cached results will still be returned, but at the same time the server will be triggered to update the cache. When you access again in the 13ths time, it is the updated result.

Simply put, the first access that exceeds the revalidate setting time will trigger a cache update. If the update is successful, subsequent returns will be new content until the next cache update is triggered.

Another option is to use the `next.revalidate` option.

In order to demonstrate its effect, we need to prepare an interface that can return data randomly.

If you like cats, you can call [api.thecatapi.com/v1/images/s…](https://link.juejin.cn/?target=https%3A%2F%2Fapi.thecatapi.com%2Fv1%2Fimages%2Fsearch "https://api.thecatapi.com/v1/images/search")，Each time it is called it will return a random cat picture data.

If you like dogs, you can call [dog.ceo/api/breeds/…](https://link.juejin.cn/?target=https%3A%2F%2Fdog.ceo%2Fapi%2Fbreeds%2Fimage%2Frandom "https://dog.ceo/api/breeds/image/random")，Each time it is called it will return a random dog picture data.

If you like beautiful girls and handsome guys, please figure it out yourself.

Let's get started now! Create a new `app/api/image/route.js` with the following code:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">export async function GET() {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  const res = await fetch(&#39;https://api.thecatapi.com/v1/images/search&#39;)</span>
<span class="code-block-extension-codeLine" data-line-num="3">  const data = await res.json()</span>
<span class="code-block-extension-codeLine" data-line-num="4">  console.log(data)</span>
<span class="code-block-extension-codeLine" data-line-num="5">  return Response.json(data)</span>
<span class="code-block-extension-codeLine" data-line-num="6">}</span>
</code></pre>

Let's open this page in development mode:

![get-cache-3.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d24ddaaf8cf74ecd89f7209696210260~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=720&h=154&s=35397&e=gif&f=20&b=fcfcfc)

You will find that unlike the previous `/api/time`, the data returned by the `/api/image` interface will not change when refreshed in development mode. Even if console.log is printed every time, the returned result is still Same.

This is because Next.js extends the native fetch method and automatically caches the fetch results. Now we use `next.revalidate` to set the revalidation time of the fetch request, modify `app/api/image/route.js`, the code is as follows:

<pre><div class="code-block-extension-header"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">export async function GET() {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  const res = await fetch(&#39;https://api.thecatapi.com/v1/images/search&#39;, {</span>
<span class="code-block-extension-codeLine" data-line-num="3">    next: { revalidate: 5 }, </span>
<span class="code-block-extension-codeLine" data-line-num="4">  })</span>
<span class="code-block-extension-codeLine" data-line-num="5">  const data = await res.json()</span>
<span class="code-block-extension-codeLine" data-line-num="6">  console.log(data)</span>
<span class="code-block-extension-codeLine" data-line-num="7">  return Response.json(data)</span>
<span class="code-block-extension-codeLine" data-line-num="8">}</span>
</code></pre>

Refresh the page locally multiple times and you will find that the data has been updated:

![get-cache-4.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61b01c30135e4776919b1eaab0e0f375~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=720&h=154&s=72128&e=gif&f=63&b=fcfcfc)

If you use the production version, although `/api/image` shows a static rendering when building, the data will be updated. The specific update rules are the same as the first solution, so I won’t go into details here.
